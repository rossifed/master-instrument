"""Unit tests for validating SQL syntax generated by templates.

These tests verify that:
1. CTEs are correctly chained (commas in the right places)
2. No double commas
3. No missing commas between CTEs
4. Valid WITH ... SELECT structure
"""

import pytest
import re
from pathlib import Path
from jinja2 import Environment, FileSystemLoader

from master_instrument.etl.loading import (
    TemplateSource,
    MergeConfig,
    UpsertConfig, 
    InsertConfig,
    MappingConfig,
    InheritanceConfig,
    SelfReferenceConfig,
    AuditConfig,
)
from master_instrument.db.models import (
    Entity, Company, EntityMapping,
    Quote, QuoteMapping,
    Region, Country,
    Venue,
)


class SQLSyntaxValidator:
    """SQL syntax validator for generated templates."""
    
    @staticmethod
    def validate_cte_structure(sql: str) -> list[str]:
        """Check CTE structure and return errors found."""
        errors = []
        
        clean_sql = SQLSyntaxValidator._normalize_sql(sql)
        
        if re.search(r',\s*,', clean_sql):
            errors.append("Double comma detected")
        
        if re.search(r'WITH\s*,', clean_sql, re.IGNORECASE):
            errors.append("Comma after WITH")
        
        for i, line in enumerate(sql.split('\n'), 1):
            stripped = line.strip()
            if stripped == ',':
                errors.append(f"Line {i}: orphan comma")
        
        # Check that CTEs are separated by commas
        if re.search(r'\)\s+[a-zA-Z_][a-zA-Z0-9_]*\s+AS\s*\(', clean_sql, re.IGNORECASE):
            errors.append("CTE missing comma before")
        
        # Check no comma before final SELECT
        if re.search(r',\s*SELECT\s+1\s*;', clean_sql, re.IGNORECASE):
            errors.append("Comma before final SELECT")
        
        # Check WITH ... SELECT structure
        if 'WITH' in clean_sql.upper():
            if not re.search(r'WITH.*SELECT', clean_sql, re.IGNORECASE | re.DOTALL):
                errors.append("WITH without final SELECT")
        
        return errors
    
    @staticmethod
    def _normalize_sql(sql: str) -> str:
        """Normalize SQL to facilitate validation checks."""
        # Remove comments
        sql = re.sub(r'--.*$', '', sql, flags=re.MULTILINE)
        # Normalize whitespace
        sql = re.sub(r'\s+', ' ', sql)
        return sql.strip()
    
    @staticmethod
    def assert_valid_sql(sql: str, context: str = ""):
        """Assert that the SQL is syntactically valid."""
        errors = SQLSyntaxValidator.validate_cte_structure(sql)
        if errors:
            error_msg = f"SQL syntax errors{' (' + context + ')' if context else ''}:\n"
            error_msg += "\n".join(f"  - {e}" for e in errors)
            error_msg += f"\n\nGenerated SQL:\n{sql[:500]}..."
            pytest.fail(error_msg)


class TestMergeSQLSyntax:
    """SQL syntax tests for MERGE template."""
    
    def test_merge_simple(self):
        """Simple MERGE without extensions."""
        config = MergeConfig.from_model(
            Region,
            source_table='intermediate.int_region',
            unique_key='code',
            schema='master',
            order_by='name'
        )
        
        source = TemplateSource(config)
        sql = source.read({})
        
        SQLSyntaxValidator.assert_valid_sql(sql, "MERGE simple - Region")
        assert 'MERGE INTO master.region' in sql
        assert 'source_query AS' in sql
    
    def test_merge_with_mapping(self):
        """MERGE with mapping table."""
        config = MergeConfig.from_model(
            Quote,
            source_table='intermediate.int_quote',
            source_unique_key='internal_quote_id',
            unique_key=['instrument_id', 'venue_id'],  # Natural business key
            schema='master',
            mapping=MappingConfig.from_model(QuoteMapping),
            order_by='instrument_id, venue_id'
        )
        
        source = TemplateSource(config)
        sql = source.read({})
        
        SQLSyntaxValidator.assert_valid_sql(sql, "MERGE with mapping - Quote")
        assert 'MERGE INTO master.quote' in sql
        assert 'update_mapping AS' in sql
        assert 'quote_mapping' in sql
    
    def test_merge_with_inheritance_and_mapping(self):
        """MERGE with inheritance (Entity -> Company) and mapping."""
        parent_config = MergeConfig.from_model(
            Entity,
            source_table='intermediate.int_company',
            unique_key='entity_id',
            schema='master'
        )
        
        config = MergeConfig.from_model(
            Company,
            source_table='intermediate.int_company',
            unique_key='company_id',
            schema='master',
            exclude_columns=['latest_interim_financial_date'],
            inheritance=InheritanceConfig(
                parent_config=parent_config,
                source_parent_key='internal_company_id'
            ),
            mapping=MappingConfig.from_model(EntityMapping),
            self_reference=SelfReferenceConfig(
                columns={
                    'primary_company_id': 'primary_company_id',
                    'ultimate_organization_id': 'ultimate_organization_id'
                },
                requires_mapping=True
            ),
            order_by='name'
        )
        
        source = TemplateSource(config)
        sql = source.read({})
        
        SQLSyntaxValidator.assert_valid_sql(sql, "MERGE inheritance+mapping - Company")
        assert 'merge_parent AS' in sql
        assert 'enriched_parent AS' in sql
        assert 'merge_child AS' in sql
        assert 'update_mapping AS' in sql
        assert 'FROM merge_parent' in sql  # Mapping must use merge_parent
    
    def test_merge_with_audit(self):
        """MERGE with audit columns."""
        config = MergeConfig.from_model(
            Region,
            source_table='intermediate.int_region',
            unique_key='code',
            schema='master',
            audit=AuditConfig(
                with_created_at=True,
                with_updated_at=True,
                with_deleted_at=False
            ),
            order_by='name'
        )
        
        source = TemplateSource(config)
        sql = source.read({})
        
        SQLSyntaxValidator.assert_valid_sql(sql, "MERGE with audit - Region")
        assert 'created_at' in sql.lower()
        assert 'updated_at' in sql.lower()


class TestUpsertSQLSyntax:
    """SQL syntax tests for UPSERT template."""
    
    def test_upsert_simple(self):
        """Simple UPSERT without extensions."""
        config = UpsertConfig.from_model(
            Country,
            source_table='seed.country',
            unique_key='code_alpha2',  # Country natural key
            schema='master',
            order_by='name'
        )
        
        source = TemplateSource(config)
        sql = source.read({})
        
        SQLSyntaxValidator.assert_valid_sql(sql, "UPSERT simple - Country")
        assert 'INSERT INTO master.country' in sql
        assert 'ON CONFLICT' in sql
        assert 'source_query AS' in sql
    
    def test_upsert_with_mapping(self):
        """UPSERT with mapping table."""
        from master_instrument.db.models import VenueMapping
        config = UpsertConfig.from_model(
            Venue,
            source_table='intermediate.int_venue',
            unique_key='venue_id',
            source_unique_key='internal_venue_id',
            schema='master',
            mapping=MappingConfig.from_model(VenueMapping),
            order_by='name'
        )
        
        source = TemplateSource(config)
        sql = source.read({})
        
        SQLSyntaxValidator.assert_valid_sql(sql, "UPSERT with mapping - Venue")
        assert 'INSERT INTO master.venue' in sql
        assert 'ON CONFLICT' in sql
    
    def test_upsert_with_audit(self):
        """UPSERT with audit columns."""
        config = UpsertConfig.from_model(
            Country,
            source_table='seed.country',
            unique_key='code_alpha2',  # Country natural key
            schema='master',
            audit=AuditConfig(
                with_created_at=True,
                with_updated_at=True,
                with_deleted_at=False
            ),
            order_by='name'
        )
        
        source = TemplateSource(config)
        sql = source.read({})
        
        SQLSyntaxValidator.assert_valid_sql(sql, "UPSERT with audit - Country")
        # Note: UPSERT may not always add created_at in all cases


class TestInsertSQLSyntax:
    """SQL syntax tests for INSERT template."""
    
    def test_insert_simple(self):
        """INSERT simple."""
        config = InsertConfig.from_model(
            Country,
            source_table='seed.country',
            unique_key='code_alpha2',  # Country natural key
            schema='master',
            order_by='name'
        )
        
        source = TemplateSource(config)
        sql = source.read({})
        
        SQLSyntaxValidator.assert_valid_sql(sql, "INSERT simple - Country")
        assert 'INSERT INTO master.country' in sql
        assert 'source_query AS' in sql


class TestCTEChaining:
    """Tests for CTE chaining."""
    
    def test_no_double_comma(self):
        """Verify no double comma ever appears."""
        configs = [
            # MERGE simple
            MergeConfig.from_model(Region, source_table='t', unique_key='code', schema='master'),
            # MERGE with mapping
            MergeConfig.from_model(
                Quote, source_table='t', source_unique_key='internal_quote_id',
                unique_key=['instrument_id', 'venue_id'],  # Natural business key
                schema='master', mapping=MappingConfig.from_model(QuoteMapping)
            ),
        ]
        
        for config in configs:
            source = TemplateSource(config)
            sql = source.read({})
            assert ',,' not in sql.replace(' ', ''), f"Double comma in: {type(config).__name__}"
    
    def test_no_orphan_comma(self):
        """Verify no orphan comma on a line."""
        parent_config = MergeConfig.from_model(
            Entity, source_table='t', unique_key='entity_id', schema='master'
        )
        config = MergeConfig.from_model(
            Company, source_table='t', unique_key='company_id', schema='master',
            inheritance=InheritanceConfig(parent_config=parent_config, source_parent_key='internal_company_id'),
            mapping=MappingConfig.from_model(EntityMapping)
        )
        
        source = TemplateSource(config)
        sql = source.read({})
        
        for i, line in enumerate(sql.split('\n'), 1):
            stripped = line.strip()
            assert stripped != ',', f"Line {i}: orphan comma"
    
    def test_cte_separator_consistency(self):
        """Verify all CTEs are separated by commas."""
        parent_config = MergeConfig.from_model(
            Entity, source_table='t', unique_key='entity_id', schema='master'
        )
        config = MergeConfig.from_model(
            Company, source_table='t', unique_key='company_id', schema='master',
            inheritance=InheritanceConfig(parent_config=parent_config, source_parent_key='internal_company_id'),
            mapping=MappingConfig.from_model(EntityMapping)
        )
        
        source = TemplateSource(config)
        sql = source.read({})
        
        # Extract CTEs
        cte_pattern = r'(\w+)\s+AS\s*\('
        ctes = re.findall(cte_pattern, sql)
        
        # Verify all expected CTEs are present
        expected_ctes = ['source_query', 'merge_parent', 'enriched_parent', 'merge_child', 'update_mapping']
        for expected in expected_ctes:
            assert expected in ctes, f"Missing CTE: {expected}"


class TestRegressionCases:
    """Regression tests for fixed bugs."""
    
    def test_regression_mapping_cte_missing_comma(self):
        """Regression: missing comma before update_mapping in MERGE with mapping."""
        config = MergeConfig.from_model(
            Quote,
            source_table='intermediate.int_quote',
            source_unique_key='internal_quote_id',
            unique_key=['instrument_id', 'venue_id'],  # Natural business key
            schema='master',
            mapping=MappingConfig.from_model(QuoteMapping),
        )
        
        source = TemplateSource(config)
        sql = source.read({})
        
        assert '),\n\nupdate_mapping' in sql or '), update_mapping' in sql.replace('\n', ' '), \
            "Missing comma before update_mapping"
    
    def test_regression_inheritance_mapping_wrong_source(self):
        """Regression: mapping must use merge_parent not source_query for inheritance."""
        parent_config = MergeConfig.from_model(
            Entity, source_table='t', unique_key='entity_id', schema='master'
        )
        config = MergeConfig.from_model(
            Company, source_table='t', unique_key='company_id', schema='master',
            inheritance=InheritanceConfig(parent_config=parent_config, source_parent_key='internal_company_id'),
            mapping=MappingConfig.from_model(EntityMapping)
        )
        
        source = TemplateSource(config)
        sql = source.read({})
        
        assert 'FROM merge_parent' in sql, "Mapping must use merge_parent, not source_query"
        assert 'entity_id' in sql.split('update_mapping')[1], "Mapping must select entity_id"
    
    def test_regression_upsert_double_comma(self):
        """Regression: double comma in simple UPSERT."""
        config = UpsertConfig.from_model(
            Country,
            source_table='seed.country',
            unique_key='code_alpha2',  # Country natural key
            schema='master',
        )
        
        source = TemplateSource(config)
        sql = source.read({})
        
        # No double comma
        clean_sql = sql.replace(' ', '').replace('\n', '')
        assert ',,' not in clean_sql, "Double comma in UPSERT"


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
