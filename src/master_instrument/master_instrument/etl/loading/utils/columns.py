"""Column classification utilities for SQLAlchemy tables.

Classifies and filters columns based on:
- Auto-generated columns (SERIAL, timestamps with defaults, server_default)
- Mixin columns (created_at, updated_at, deleted_at)
- Foreign key detection and pattern matching
- Explicit exclusions

Note: Columns with server_default (like sys_period) are automatically excluded
by auto_exclude_server_defaults=True. No need for hardcoded column names.
"""

from typing import Any, Optional, Set, Type, List
from sqlalchemy.schema import Table


KNOWN_MIXIN_COLUMNS = {'created_at', 'updated_at', 'deleted_at'}

# Patterns that indicate truly auto-generated values (should be excluded from MERGE)
# These are values the database generates that we shouldn't override
AUTO_GENERATED_PATTERNS = [
    'current_timestamp',
    'now()',
    'gen_random_uuid()',
    'nextval(',
    'tstzrange(',
]

# Simple literal defaults that should NOT be excluded
# These are just default values, not auto-generated
SIMPLE_DEFAULT_VALUES = {'true', 'false', '0', '1', "''", 'null'}


def _get_server_default_text(col: Any) -> str:
    """Extract text representation of server_default."""
    if col.server_default is None:
        return ''
    if hasattr(col.server_default, 'arg'):
        arg = col.server_default.arg
        if hasattr(arg, 'text'):
            return str(arg.text).lower()
        return str(arg).lower()
    return str(col.server_default).lower()


def is_truly_auto_generated_default(col: Any) -> bool:
    """Check if server_default is a truly auto-generated value.
    
    Returns True for values like:
    - CURRENT_TIMESTAMP, now()
    - gen_random_uuid()
    - tstzrange(current_timestamp, NULL)
    - nextval('sequence')
    
    Returns False for simple literal defaults like:
    - 'false', 'true' (booleans)
    - '0', '1' (integers)
    - NULL
    """
    if col.server_default is None:
        return False
    
    default_text = _get_server_default_text(col)
    
    # Check if it's a simple literal default (should NOT be excluded)
    if default_text in SIMPLE_DEFAULT_VALUES:
        return False
    
    # Check if it matches auto-generated patterns (SHOULD be excluded)
    for pattern in AUTO_GENERATED_PATTERNS:
        if pattern in default_text:
            return True
    
    return False


def has_default_value(col: Any) -> bool:
    """Check if column has server_default or default that is truly auto-generated.
    
    Note: Simple defaults like 'false' for booleans are NOT considered
    auto-generated and will NOT cause exclusion.
    """
    # Only exclude if it's truly auto-generated
    if is_truly_auto_generated_default(col):
        return True
    
    # Python-side defaults are generally not auto-generated
    # They're handled by SQLAlchemy, not the DB, so we don't exclude them
    return False


def is_auto_pk(col: Any) -> bool:
    """Check if column is an auto-increment primary key.
    
    Only returns True if autoincrement=True is EXPLICITLY set.
    This avoids guessing based on type or composite PK detection.
    
    Convention: All auto-increment PKs in models should have autoincrement=True.
    """
    return col.primary_key and col.autoincrement is True


def is_auto_generated(col: Any) -> bool:
    """Check if column is auto-generated by database."""
    return has_default_value(col) or is_auto_pk(col)


def get_auto_generated_column_names(table: Table) -> Set[str]:  # type: ignore[type-arg]
    """Extract names of auto-generated columns."""
    return {col.name for col in table.columns if is_auto_generated(col)}


def is_mixin_with_table(base: Type[Any]) -> bool:
    """Check if base class is a mixin with __table__."""
    return 'Mixin' in base.__name__ and hasattr(base, '__table__')


def extract_mixin_columns(base: Type[Any]) -> Set[str]:
    """Extract column names from mixin base class."""
    return {col.name for col in base.__table__.columns}  # type: ignore[attr-defined]


def get_mixin_columns_from_mro(model: Type[Any]) -> Set[str]:
    """Extract columns from mixin classes in MRO."""
    mixin_bases = [b for b in model.__mro__ if is_mixin_with_table(b)]
    if not mixin_bases:
        return set()
    all_columns: Set[str] = set().union(*[extract_mixin_columns(b) for b in mixin_bases])
    return all_columns


def get_known_mixin_columns(model: Type[Any]) -> Set[str]:
    """Extract known mixin columns present in model."""
    if not hasattr(model, '__table__'):
        return set()
    table_cols = {col.name for col in model.__table__.columns}  # type: ignore[attr-defined]
    return table_cols & KNOWN_MIXIN_COLUMNS


def get_mixin_columns(model: Type[Any]) -> Set[str]:
    """Extract all mixin columns from model (MRO + known patterns)."""
    return get_mixin_columns_from_mro(model) | get_known_mixin_columns(model)


def get_mixin_exclusions(model: Optional[Type[Any]], exclude_mixins: bool) -> Set[str]:
    """Get mixin columns to exclude (conditional)."""
    return get_mixin_columns(model) if exclude_mixins and model else set()


def get_auto_exclusions(table: Table, auto_exclude: bool) -> Set[str]:  # type: ignore[type-arg]
    """Get auto-generated columns to exclude (conditional).
    
    This includes:
    - Columns with server_default (e.g., sys_period, created_at with NOW())
    - Columns with default (Python-side defaults)
    - Columns with autoincrement=True (e.g., SERIAL PKs)
    """
    return get_auto_generated_column_names(table) if auto_exclude else set()


def build_excluded_columns(
    table: Table,  # type: ignore[type-arg]
    exclude_columns: Optional[List[str]],
    exclude_mixins: bool,
    auto_exclude_server_defaults: bool,
    model: Optional[Type[Any]]
) -> Set[str]:
    """Build complete set of columns to exclude based on all criteria."""
    return (
        set(exclude_columns or []) |
        get_mixin_exclusions(model, exclude_mixins) |
        get_auto_exclusions(table, auto_exclude_server_defaults)
    )


def get_all_columns(
    table: Table,  # type: ignore[type-arg]
    exclude_columns: Optional[List[str]] = None,
    exclude_mixins: bool = True,
    auto_exclude_server_defaults: bool = True,
    model: Optional[Type[Any]] = None
) -> List[str]:
    """Get all non-excluded column names.
    
    Args:
        table: SQLAlchemy Table
        exclude_columns: Explicit columns to exclude
        exclude_mixins: Auto-exclude mixin columns (created_at, updated_at, deleted_at)
        auto_exclude_server_defaults: Auto-exclude auto-generated columns
            (server_default, default, autoincrement=True)
        model: Model class (required if exclude_mixins=True)
        
    Returns:
        List of column names after applying all exclusions
        
    Note:
        Columns with server_default (like sys_period with tstzrange default)
        are automatically excluded when auto_exclude_server_defaults=True.
    """
    all_cols = [col.name for col in table.columns]  # type: ignore[attr-defined]
    excluded = build_excluded_columns(
        table, exclude_columns, exclude_mixins, 
        auto_exclude_server_defaults, model
    )
    return [col for col in all_cols if col not in excluded]


def get_fk_column_name(fk_constraint: Any) -> str:
    """Extract column name from FK constraint."""
    return list(fk_constraint.columns)[0].name


def matches_fk_pattern(fk_constraint: Any, pattern: str) -> bool:
    """Check if FK references table matching pattern."""
    try:
        return pattern in fk_constraint.referred_table.fullname
    except Exception:
        return False


def detect_fk_column(table: Table, pattern: str, fallback: Optional[str] = None) -> Optional[str]:  # type: ignore[type-arg]
    """Detect foreign key column by referenced table pattern or fallback name.
    
    Args:
        table: SQLAlchemy Table
        pattern: String to match in referenced table name
        fallback: Fallback column name if pattern matching fails
        
    Returns:
        Column name if found, None otherwise
    """
    for fk in table.foreign_key_constraints:
        fk_column = get_fk_column_name(fk)
        
        if matches_fk_pattern(fk, pattern):
            return fk_column
        
        if fallback and fk_column == fallback:
            return fk_column
    
    return None


def detect_fk_by_column_pattern(table: Table, column_pattern: str) -> Optional[str]:  # type: ignore[type-arg]
    """Detect FK column by column name pattern (e.g., 'internal_*').
    
    Args:
        table: SQLAlchemy Table
        column_pattern: Pattern to match column name (supports startswith)
        
    Returns:
        First matching FK column name, or None
    """
    for fk in table.foreign_key_constraints:
        fk_column = get_fk_column_name(fk)
        if fk_column.startswith(column_pattern):
            return fk_column
    return None
